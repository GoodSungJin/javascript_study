---
title: '[T.I.L] 복습, 개념정리'
date: 2019-05-06
categories:
- T.I.L

---

# 1. 웹브라우저

HTTP 프로토콜을 이용해 서버와 브라우저가 Request(요청)와 Response(응답)을 주고 받는다. 서버가 Response를 주면 렌더링 엔진(HTML, CSS)과, 자바스크립트 엔진(JavaScript)에 의해 Parsing(텍스트로 된 파일을 컴퓨터가 알수있게 해석하는 것)된다. Parsing된 결과는 DOM(HTML이 해석된 결과), CSSOM(CSS가 해석된 결과), Sysntax Tree(JavaScript가 해석된 결과)트리로 변환 되고 DOM과 CSSOM 트리가 완성되면 Sysntax Tree가 앞에 두개에 영향을 끼쳐 Render Tree(다 합쳐진결과)로 결합된다.


---

# 2. 변수

<br>

## 2.1. 할당과 참조

예제) 숫자 값 10과 20을 + 연산자로 합산하고 있다.

```javascript
10 + 20
```

숫자 값 10과 20은 메모리 상의 임의의 위치(주소, address)에 저장되고, 연산 결과로 생성된 숫자 값 30도 메모리 상의 임의의 위치에 저장되지만 숫자 값 30은 재사용할 수 없다.

**값의 재사용을 위해 변수(하나의 값을 저장할 수 있는 메모리 공간에 붙인 이름 또는 메모리 공간 자체를 말한다)를 사용**한다. 

---

예제) 숫자 값 10과 20을 + 연산자로 합산하고, 변수 result 에 저장한다.

```javascript
var result = 10 + 20;
```

숫자 값 10과 20을 합산한 결과를 변수 `result`에 저장하는 것을 **할당**이라 하고, 변수에 저장 된 값을 읽어 들이는 것을 **참조**라고 한다.

> **변수명**은 **식별자**로도 부른다. 식별자가 상위의 개념이고 변수, 함수, 클래스 등의 이름과 같은 식별자는 모두 선언에 의해 자바 스크립트 엔진에 식별자의 존재를 알린다.

---

## 2.2. 변수 선언

**변수 선언**이란 변수명을 등록하여 자바스크립트 엔진에 변수의 존재를 알려 관리하도록 하는 것을 말한다. 변수를 사용하려면 반드시 선언이 필요하다. 선언시 var, let, const 키워드를 사용한다.

```javascript
var score;	// 변수의 선언(변수 선언문)
```

키워드 var를 이용해 score라는 변수를 선언했다. 아직 값을 할당하지 않았지만 자바스크립트 엔진에 의해 `undefined`라는 값이 암묵적으로 할당되어 있다.

---

## 2.3. 변수 선언의 실행 시점과 변수 호이스팅

```javascript
console.log(score);	// undefined
var score;
```

자바스크립트는 한줄씩 순차적으로 실행되므로 변수의 선언보다 참조가 앞에 있으면 에러를  발생할 것처럼 보인다. 하지만 에러는 발생하지 않는다. 위에 출력은 `undefined`로 나타난다. 

자바스크립트는 변수 선언을 우선적으로 처리하기 때문이다. 런타임(소스코드가 순차적으로 실행되는 시점)이 아닌 이전의 파싱타임에 먼저 시행시켜 **호이스팅**이라는 작업을 하기 때문이다. 모든 선언문은 런타임이 아닌 파싱 타임에 먼저 실행된다.

---

## 2.4. 값의 할당

```javascript
var score;	// 변수 선언
score = 30;	// 값의 할당

var score = 30;	// 변수 선언과 값의 할당
```

변수에 값을 할당할 때는 할당 연산자(=)를 기준으로 우변의 값을 좌변에 할당한다.

변수 `score`를 선언한 시점에는 `undefined`로 초기화되어 있다. `score=30`으로 값을 할당하는 행위는 엄밀히 따지면 30으로 값을 재할당했다고 한다.

> const 키워드
>
> const는 상수를 표현하는 키워드로 값의 재할당이 금지된다.

---

## 2.5. 식별자 네이밍 규칙

```javascript
// 카멜 케이스
var firstName;

// 스네이크 케이스
var first_name;

// 파스칼 케이스
var FirstName;

// 헝가리언 케이스
var strFirstName;	// type + identifier
```

---

# 3. 데이터 타입

모든 값은 메모리에 저장하고 참조할 수 있어야 한다. 메모리에 값을 할당하고 참조하기 위해서는 확보해야할 메모리 공간의 크기와 읽어와야할 메모리 공간의 크기를 알아야한다.

```javascript
var score = 100;	// type Number = 8byte;
```

위 예제에서 자바스크립트 엔진은 값 100을 숫자 타입으로 인식하고 선두 메모리 셀을 기준으로 8byte의 메모리 공간을 확보한다.

```javascript
score
```

참조를 위해서는 메모리 공간의 선두 메모리 셀의 주소를 찾아갈 필요가 있다. 이때 컴퓨터는 한번에 읽어 들여야 할 메모리 공간의 크기, 즉 메모리 셀의 개수(byte 수)를 알아야 한다. 변수 score에는 숫자 타입의 값이 할당되어 있으므로 선두 메모리 셀을 기준으로 셀 8개를 읽어온다.

- 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해
- 값을 참조할 때 한번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해
- 메모리에서 읽어 들인 2진수를 어떻게 해석할 지를 결정하기 위해

---

# 4. 연산자

<br>

## 4.1.  표현식과 연산자

**표현식은 하나의 값으로 평가될 수 있는 문**이다.

표현식은 리터럴 표현식, 식별자 표현식, 연산자 표현식, 함수/메소드 호출 표현식 등이 있지만 결국 평가되어 하나의 값이 된다.

<br>

## 4.2. 문과 표현식

**문은 하나 이상의 표현식과 키워드의 조합으로 구성되어 자바스크립트 엔진에게 내리는 명령**이다. 자바스크립트의 모든 코드는 문 또는 표현식이다.

표현식의 역할은 값을 생성하는 것이다. 문의 역할은 표현식으로 생성한 값을 사용해 자바스크립트 엔진에게 명령을 내리는 것이다.

<br>

## 4.3. 표현식인 문과 표현식이 아닌 문

**표현식인 문과 아닌 문을 구별하기 위한 가장 간단한 방법은 병수에 할당해 보는 것이다.**

표현식인 문은 변수에 할당할 수 있고, 표현식이 아닌 문은 값으로 평가할 수 없으므로 변수에 할당할 수 없어서 에러가 발생한다.

```javascript
// 변수 선언문은 표현식이 아닌 문이다.
var x;
// 따라서 변수 선언문은 표현식이 아닌 문이다.
var x = var y;	// SyntaxError

// 할당문 자체가 표현식이지만 완전한 문이기도 하다. 즉, 할당문은 표현식인 문이다.
x = 100;
```

<br>

## 4.4. 연산자란?

하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입 연산등을 수행해 하나의 값을 만든다. 연산의 대상을 피연산자라 부른다.

<br>

## 4.5. 산술 연산자

산술연산자는 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만든다. 산술 연산이 불가능한 경우, NaN을 반환한다.

산술 연산자는 피연산자의 개수에 따라 이항 산술 연산자와 단항 산술 연산자로 구분할 수 있다.

<br>

### 4.5.1. 이항 산술 연산자

이항 산술 연산자는 2개의 피연산자를 산술 연산하여 숫자 타입의 값을 만든다. 피연산자의 값이 바뀌지 않고 언제나 새로운 값을 만든다.

- `+` : 덧셈
- `-` : 뺄셈
- `*` : 곱셈
- `/` : 나눗셈
- `%` : 나머지

### 4.5.2. 단항 산술 연산자

단항 산술 연산자는 1개의 피연산자를 산술 연산하여 숫자 타입의 값을 만든다.  증가/감소(++ / --) 연산자는 피연산자의 값을 변경하는 부수 효과가 있다. 다시 말해 증가/감소 연산을 하면 피연산자의 값이 바뀐다.

- `++` : 증가
- `--` : 감소
- `+` :  어떠한 효과도 없다.
- `-` : 양수를 음수로 음수를 양수로 반전한 값을 반환한다.

<br>

## 4.5. 할당 연산자

할당 연산자는 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다. 할당 연산자는 좌항의 변수에 값을 할당하므로 변수의 값이 변하는 부수 효과가 있다.

```javascript
// =  +=  -=  *=  /=  %=

x = 10;	// 10

x += 5;	// x = x + 5	15

x -= 5;	// x =  x - 5	10

x *= 5;	// x = x * 5	50

x /= 5;	// x = x / 5	10

x %= 5;	// x = x % 5	0
```



<br>

## 4.6. 비교 연산자

비교 연산자는 좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값을 반환한다. 비교 연산자는 if 문이나 for 문과 같은 제어문의 조건식에서 주로 사용한다.

- `==` : 동등 비교 ( x == y, x와 y의 값이 같음)
- `===` : 일치 비교 (x === y, x와 y의 값과 타입이 같음)
- `!=` : 부동등 비교 (x != y, x와 y의 값이 다름)
- `!==` : 불일치 비교 (x !== y, x와 y의 값과 타입이 다름)

```javascript
// 동등 비교
5 == 5		// true

// 타입은 다르지만 암묵적 타입 변환을 한다.
5 == '5'	// ture

// 일치 비교
5 === 5		// true

// 암묵적 타입 변환을 하지 않고 값을 비교한다.
// 즉, 값과 타입이 모두 같은 경우만 true를 반환한다.
5 === '5'	// false
```

<br>

## 4. 7. 대소 관계 비교 연산자

대소 관계 비교 연산자는 피연산자의 크기를 비교하여 불리언 값을 반환한다.

- `>` : x > y, x가 y보다 크다.
- `<` : x < y, x가 y보다 작다.
- `>=` : x >= y, x가 y보다 크거다 같다.
- `<=` : x <= y, x가 y보다 크거다 작다.

```javascript
5 > 0	// true
5 > 5	// false
5 >= 5 	// true
5 <= 5	// true
```

<br>

## 4.8. 삼항 조건 연산자

삼항 조건 연산자는 조건식의 평가 결과에 따라 반환할 값을 결정한다.

```
조건식 ? 조건식이 true 일 때 반환할 값 : 조건식이 false일 때 반환할 값
```

```javascript
var x = 2;

// 2 % 2 는 0이고 0은 false로 암묵적 타입 변환이 된다.
var result = x % 2 ? '홀수' : '짝수';

console.log(result);	// 짝수


// if...else문으로 동일한 처리
var x = 2;
var result;

if(x % 2){
    result = '홀수';
} else{
    result = '짝수';
}

console.log(result);	// 짝수
```

삼항 조건 연산자와 if...else문은 동일하게 사용할수 있지만 if...else문은 표현식이 아닌문이다. 따라서 if...else 문은 값처럼 사용할 수 없다.

<br>

## 4.9. 논리 연산자

논리 연산자는 우항과 좌항의 피연산자(부정 논리 연산자의 경우, 우항의 피연산자)를 논리 연산한다.

- `||` : 논리합(OR)
- `&&` : 논리곱(AND)
- `!` : 부정(NOT)

```javascript
// 논리합(||) 연산자
console.log(true || true);   // true
console.log(true || false);  // true
console.log(false || true);  // true
console.log(false || false); // false

// 논리곱(&&) 연산자
console.log(true && true);   // true
console.log(true && false);  // false
console.log(false && true);  // false
console.log(false && false); // false

// 논리 부정(!) 연산자
console.log(!true);  // false
console.log(!false); // true
```

